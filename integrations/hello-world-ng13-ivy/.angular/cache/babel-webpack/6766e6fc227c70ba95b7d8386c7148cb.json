{
  "ast": null,
  "code": "import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule } from '@angular/core';\nimport { getActionTypeFromInstance, Store, NGXS_PLUGINS } from '@ngxs/store';\nimport { tap, catchError } from 'rxjs/operators';\n\nconst repeat = (str, times) => new Array(times + 1).join(str);\n\nconst pad = (num, maxLength) => repeat('0', maxLength - num.toString().length) + num;\n\nfunction formatTime(time) {\n  return pad(time.getHours(), 2) + `:` + pad(time.getMinutes(), 2) + `:` + pad(time.getSeconds(), 2) + `.` + pad(time.getMilliseconds(), 3);\n}\n\nclass ActionLogger {\n  constructor(action, store, logWriter) {\n    this.action = action;\n    this.store = store;\n    this.logWriter = logWriter;\n  }\n\n  dispatched(state) {\n    const actionName = getActionTypeFromInstance(this.action);\n    const formattedTime = formatTime(new Date());\n    const message = `action ${actionName} @ ${formattedTime}`;\n    this.logWriter.startGroup(message); // print payload only if at least one property is supplied\n\n    if (this._hasPayload(this.action)) {\n      this.logWriter.logGrey('payload', Object.assign({}, this.action));\n    }\n\n    this.logWriter.logGrey('prev state', state);\n  }\n\n  completed(nextState) {\n    this.logWriter.logGreen('next state', nextState);\n    this.logWriter.endGroup();\n  }\n\n  errored(error) {\n    this.logWriter.logRedish('next state after error', this.store.snapshot());\n    this.logWriter.logRedish('error', error);\n    this.logWriter.endGroup();\n  }\n\n  _hasPayload(event) {\n    const nonEmptyProperties = this._getNonEmptyProperties(event);\n\n    return nonEmptyProperties.length > 0;\n  }\n\n  _getNonEmptyProperties(event) {\n    const keys = Object.keys(event);\n    const values = keys.map(key => event[key]);\n    return values.filter(value => value !== undefined);\n  }\n\n}\n\nclass LogWriter {\n  constructor(options) {\n    this.options = options;\n    this.options = this.options || {};\n    this.logger = options.logger || console;\n  }\n\n  startGroup(message) {\n    const startGroupFn = this.options.collapsed ? this.logger.groupCollapsed : this.logger.group;\n\n    try {\n      startGroupFn.call(this.logger, message);\n    } catch (e) {\n      console.log(message);\n    }\n  }\n\n  endGroup() {\n    try {\n      this.logger.groupEnd();\n    } catch (e) {\n      this.logger.log('—— log end ——');\n    }\n  }\n\n  logGrey(title, payload) {\n    const greyStyle = 'color: #9E9E9E; font-weight: bold';\n    this.log(title, greyStyle, payload);\n  }\n\n  logGreen(title, payload) {\n    const greenStyle = 'color: #4CAF50; font-weight: bold';\n    this.log(title, greenStyle, payload);\n  }\n\n  logRedish(title, payload) {\n    const redishStyle = 'color: #FD8182; font-weight: bold';\n    this.log(title, redishStyle, payload);\n  }\n\n  log(title, color, payload) {\n    if (this.isIE()) {\n      this.logger.log(title, payload);\n    } else {\n      this.logger.log('%c ' + title, color, payload);\n    }\n  }\n\n  isIE() {\n    const ua = typeof window !== 'undefined' && window.navigator.userAgent ? window.navigator.userAgent : '';\n    let msIE = false;\n    const oldIE = ua.indexOf('MSIE ');\n    const newIE = ua.indexOf('Trident/');\n\n    if (oldIE > -1 || newIE > -1) {\n      msIE = true;\n    }\n\n    return msIE;\n  }\n\n}\n\nconst NGXS_LOGGER_PLUGIN_OPTIONS = new InjectionToken('NGXS_LOGGER_PLUGIN_OPTIONS');\nlet NgxsLoggerPlugin = /*#__PURE__*/(() => {\n  class NgxsLoggerPlugin {\n    constructor(_options, _injector) {\n      this._options = _options;\n      this._injector = _injector;\n    }\n\n    handle(state, event, next) {\n      if (this._options.disabled || !this._options.filter(event, state)) {\n        return next(state, event);\n      }\n\n      this._logWriter = this._logWriter || new LogWriter(this._options); // Retrieve lazily to avoid cyclic dependency exception\n\n      this._store = this._store || this._injector.get(Store);\n      const actionLogger = new ActionLogger(event, this._store, this._logWriter);\n      actionLogger.dispatched(state);\n      return next(state, event).pipe(tap(nextState => {\n        actionLogger.completed(nextState);\n      }), catchError(error => {\n        actionLogger.errored(error);\n        throw error;\n      }));\n    }\n\n  }\n\n  /** @nocollapse */\n  NgxsLoggerPlugin.ɵfac = function NgxsLoggerPlugin_Factory(t) {\n    return new (t || NgxsLoggerPlugin)(i0.ɵɵinject(NGXS_LOGGER_PLUGIN_OPTIONS), i0.ɵɵinject(i0.Injector));\n  };\n  /** @nocollapse */\n\n\n  NgxsLoggerPlugin.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxsLoggerPlugin,\n    factory: NgxsLoggerPlugin.ɵfac\n  });\n  return NgxsLoggerPlugin;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst USER_OPTIONS = new InjectionToken('LOGGER_USER_OPTIONS');\n\nfunction loggerOptionsFactory(options) {\n  const defaultLoggerOptions = {\n    logger: console,\n    collapsed: false,\n    disabled: false,\n    filter: () => true\n  };\n  return Object.assign(Object.assign({}, defaultLoggerOptions), options);\n}\n\nlet NgxsLoggerPluginModule = /*#__PURE__*/(() => {\n  class NgxsLoggerPluginModule {\n    static forRoot(options) {\n      return {\n        ngModule: NgxsLoggerPluginModule,\n        providers: [{\n          provide: NGXS_PLUGINS,\n          useClass: NgxsLoggerPlugin,\n          multi: true\n        }, {\n          provide: USER_OPTIONS,\n          useValue: options\n        }, {\n          provide: NGXS_LOGGER_PLUGIN_OPTIONS,\n          useFactory: loggerOptionsFactory,\n          deps: [USER_OPTIONS]\n        }]\n      };\n    }\n\n  }\n\n  /** @nocollapse */\n  NgxsLoggerPluginModule.ɵfac = function NgxsLoggerPluginModule_Factory(t) {\n    return new (t || NgxsLoggerPluginModule)();\n  };\n  /** @nocollapse */\n\n\n  NgxsLoggerPluginModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsLoggerPluginModule\n  });\n  /** @nocollapse */\n\n  NgxsLoggerPluginModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NgxsLoggerPluginModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The public api for consumers of @ngxs/logger-plugin\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NGXS_LOGGER_PLUGIN_OPTIONS, NgxsLoggerPlugin, NgxsLoggerPluginModule }; //# sourceMappingURL=ngxs-logger-plugin.js.map",
  "map": null,
  "metadata": {},
  "sourceType": "module"
}
