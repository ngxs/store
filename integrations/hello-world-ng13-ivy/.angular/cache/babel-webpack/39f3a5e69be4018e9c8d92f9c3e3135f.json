{
  "ast": null,
  "code": "import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken } from '@angular/core';\nimport { ReplaySubject } from 'rxjs';\n\nfunction isAngularInTestMode() {\n  // This is safe to check for these properties in the following way since `typeof` does not\n  // throw an exception if the value does not exist in the scope.\n  // We should not try to read these values from the global scope (e.g. `ɵglobal` from the `@angular/core`).\n  // This is related to how these frameworks compile and execute modules. E.g. Jest wraps the module into\n  // its internal code where `jest` variable exists in the scope. It cannot be read from the global scope, e.g.\n  // this will return undefined `global.jest`, but `jest` will not equal undefined.\n  return typeof __karma__ !== 'undefined' || typeof jasmine !== 'undefined' || typeof jest !== 'undefined' || typeof Mocha !== 'undefined';\n}\n\nlet NgxsBootstrapper = /*#__PURE__*/(() => {\n  class NgxsBootstrapper {\n    constructor() {\n      /**\n       * Use `ReplaySubject`, thus we can get cached value even if the stream is completed\n       */\n      this.bootstrap$ = new ReplaySubject(1);\n    }\n\n    get appBootstrapped$() {\n      return this.bootstrap$.asObservable();\n    }\n    /**\n     * This event will be emitted after attaching `ComponentRef` of the root component\n     * to the tree of views, that's a signal that application has been fully rendered\n     */\n\n\n    bootstrap() {\n      this.bootstrap$.next(true);\n      this.bootstrap$.complete();\n    }\n\n  }\n\n  /** @nocollapse */\n  NgxsBootstrapper.ɵfac = function NgxsBootstrapper_Factory(t) {\n    return new (t || NgxsBootstrapper)();\n  };\n  /** @nocollapse */\n\n\n  NgxsBootstrapper.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxsBootstrapper,\n    factory: NgxsBootstrapper.ɵfac,\n    providedIn: 'root'\n  });\n  return NgxsBootstrapper;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction defaultEqualityCheck(a, b) {\n  return a === b;\n}\n\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false;\n  } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n\n\n  const length = prev.length;\n\n  for (let i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Memoize a function on its last inputs only.\n * Originally from: https://github.com/reduxjs/reselect/blob/master/src/index.js\n *\n * @ignore\n */\n\n\nfunction memoize(func, equalityCheck = defaultEqualityCheck) {\n  let lastArgs = null;\n  let lastResult = null; // we reference arguments instead of spreading them for performance reasons\n\n  function memoized() {\n    // eslint-disable-next-line prefer-rest-params\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n      // apply arguments instead of spreading for performance.\n      // eslint-disable-next-line prefer-rest-params, prefer-spread\n      lastResult = func.apply(null, arguments);\n    } // eslint-disable-next-line prefer-rest-params\n\n\n    lastArgs = arguments;\n    return lastResult;\n  }\n\n  memoized.reset = function () {\n    // The hidden (for now) ability to reset the memoization\n    lastArgs = null;\n    lastResult = null;\n  };\n\n  return memoized;\n}\n\nlet InitialState = /*#__PURE__*/(() => {\n  class InitialState {\n    static set(state) {\n      this._value = state;\n    }\n\n    static pop() {\n      const state = this._value;\n      this._value = {};\n      return state;\n    }\n\n  }\n\n  InitialState._value = {};\n  return InitialState;\n})();\nconst INITIAL_STATE_TOKEN = new InjectionToken('INITIAL_STATE_TOKEN', {\n  providedIn: 'root',\n  factory: () => InitialState.pop()\n}); // These tokens are internal and can change at any point.\n\nconst ɵNGXS_STATE_FACTORY = new InjectionToken('ɵNGXS_STATE_FACTORY');\nconst ɵNGXS_STATE_CONTEXT_FACTORY = new InjectionToken('ɵNGXS_STATE_CONTEXT_FACTORY');\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INITIAL_STATE_TOKEN, InitialState, NgxsBootstrapper, isAngularInTestMode, memoize, ɵNGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY }; //# sourceMappingURL=ngxs-store-internals.js.map",
  "map": null,
  "metadata": {},
  "sourceType": "module"
}
