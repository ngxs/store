{
  "ast": null,
  "code": "import * as i0 from '@angular/core';\nimport { InjectionToken, ɵglobal, Injectable, Inject, NgModule } from '@angular/core';\nimport { Store, getActionTypeFromInstance, NGXS_PLUGINS } from '@ngxs/store';\nimport { catchError, tap } from 'rxjs/operators';\nconst NGXS_DEVTOOLS_OPTIONS = new InjectionToken('NGXS_DEVTOOLS_OPTIONS');\n/**\n * Adds support for the Redux Devtools extension:\n * http://extension.remotedev.io/\n */\n\nlet NgxsReduxDevtoolsPlugin = /*#__PURE__*/(() => {\n  class NgxsReduxDevtoolsPlugin {\n    constructor(_options, _injector, _ngZone) {\n      this._options = _options;\n      this._injector = _injector;\n      this._ngZone = _ngZone;\n      this.devtoolsExtension = null;\n      this.globalDevtools = ɵglobal['__REDUX_DEVTOOLS_EXTENSION__'] || ɵglobal['devToolsExtension'];\n      this.unsubscribe = null;\n      this.connect();\n    }\n\n    ngOnDestroy() {\n      if (this.unsubscribe !== null) {\n        this.unsubscribe();\n      }\n\n      if (this.globalDevtools) {\n        this.globalDevtools.disconnect();\n      }\n    }\n    /**\n     * Lazy get the store for circular dependency issues\n     */\n\n\n    get store() {\n      return this._injector.get(Store);\n    }\n    /**\n     * Middleware handle function\n     */\n\n\n    handle(state, action, next) {\n      if (!this.devtoolsExtension || this._options.disabled) {\n        return next(state, action);\n      }\n\n      return next(state, action).pipe(catchError(error => {\n        const newState = this.store.snapshot();\n        this.sendToDevTools(state, action, newState);\n        throw error;\n      }), tap(newState => {\n        this.sendToDevTools(state, action, newState);\n      }));\n    }\n\n    sendToDevTools(state, action, newState) {\n      const type = getActionTypeFromInstance(action); // if init action, send initial state to dev tools\n\n      const isInitAction = type === '@@INIT';\n\n      if (isInitAction) {\n        this.devtoolsExtension.init(state);\n      } else {\n        this.devtoolsExtension.send(Object.assign(Object.assign({}, action), {\n          action: null,\n          type\n        }), newState);\n      }\n    }\n    /**\n     * Handle the action from the dev tools subscription\n     */\n\n\n    dispatched(action) {\n      if (action.type === \"DISPATCH\"\n      /* Dispatch */\n      ) {\n        if (action.payload.type === \"JUMP_TO_ACTION\"\n        /* JumpToAction */\n        || action.payload.type === \"JUMP_TO_STATE\"\n        /* JumpToState */\n        ) {\n          const prevState = JSON.parse(action.state); // This makes the DevTools and Router plugins friends with each other.\n          // We're checking for the `router` state to exist, and it also should\n          // have the `trigger` property, so we're sure that this is our router\n          // state (coming from `@ngxs/router-plugin`). This enables a time-traveling\n          // feature since it doesn't only restore the state but also allows the `RouterState`\n          // to navigate back when the action is jumped.\n\n          if (prevState.router && prevState.router.trigger) {\n            prevState.router.trigger = 'devtools';\n          }\n\n          this.store.reset(prevState);\n        } else if (action.payload.type === \"TOGGLE_ACTION\"\n        /* ToggleAction */\n        ) {\n          console.warn('Skip is not supported at this time.');\n        } else if (action.payload.type === \"IMPORT_STATE\"\n        /* ImportState */\n        ) {\n          const {\n            actionsById,\n            computedStates,\n            currentStateIndex\n          } = action.payload.nextLiftedState;\n          this.devtoolsExtension.init(computedStates[0].state);\n          Object.keys(actionsById).filter(actionId => actionId !== '0').forEach(actionId => this.devtoolsExtension.send(actionsById[actionId], computedStates[actionId].state));\n          this.store.reset(computedStates[currentStateIndex].state);\n        }\n      } else if (action.type === \"ACTION\"\n      /* Action */\n      ) {\n        const actionPayload = JSON.parse(action.payload);\n        this.store.dispatch(actionPayload);\n      }\n    }\n\n    connect() {\n      if (!this.globalDevtools || this._options.disabled) {\n        return;\n      } // The `connect` method adds `message` event listener since it communicates\n      // with an extension through `window.postMessage` and message events.\n      // We handle only 2 events; thus, we don't want to run many change detections\n      // because the extension sends events that we don't have to handle.\n\n\n      this.devtoolsExtension = this._ngZone.runOutsideAngular(() => this.globalDevtools.connect(this._options));\n      this.unsubscribe = this.devtoolsExtension.subscribe(action => {\n        if (action.type === \"DISPATCH\"\n        /* Dispatch */\n        || action.type === \"ACTION\"\n        /* Action */\n        ) {\n          this._ngZone.run(() => {\n            this.dispatched(action);\n          });\n        }\n      });\n    }\n\n  }\n\n  /** @nocollapse */\n  NgxsReduxDevtoolsPlugin.ɵfac = function NgxsReduxDevtoolsPlugin_Factory(t) {\n    return new (t || NgxsReduxDevtoolsPlugin)(i0.ɵɵinject(NGXS_DEVTOOLS_OPTIONS), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  NgxsReduxDevtoolsPlugin.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxsReduxDevtoolsPlugin,\n    factory: NgxsReduxDevtoolsPlugin.ɵfac\n  });\n  return NgxsReduxDevtoolsPlugin;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction devtoolsOptionsFactory(options) {\n  return Object.assign({\n    name: 'NGXS'\n  }, options);\n}\n\nconst USER_OPTIONS = new InjectionToken('USER_OPTIONS');\nlet NgxsReduxDevtoolsPluginModule = /*#__PURE__*/(() => {\n  class NgxsReduxDevtoolsPluginModule {\n    static forRoot(options) {\n      return {\n        ngModule: NgxsReduxDevtoolsPluginModule,\n        providers: [{\n          provide: NGXS_PLUGINS,\n          useClass: NgxsReduxDevtoolsPlugin,\n          multi: true\n        }, {\n          provide: USER_OPTIONS,\n          useValue: options\n        }, {\n          provide: NGXS_DEVTOOLS_OPTIONS,\n          useFactory: devtoolsOptionsFactory,\n          deps: [USER_OPTIONS]\n        }]\n      };\n    }\n\n  }\n\n  /** @nocollapse */\n  NgxsReduxDevtoolsPluginModule.ɵfac = function NgxsReduxDevtoolsPluginModule_Factory(t) {\n    return new (t || NgxsReduxDevtoolsPluginModule)();\n  };\n  /** @nocollapse */\n\n\n  NgxsReduxDevtoolsPluginModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsReduxDevtoolsPluginModule\n  });\n  /** @nocollapse */\n\n  NgxsReduxDevtoolsPluginModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NgxsReduxDevtoolsPluginModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The public api for consumers of @ngxs/devtools-plugin\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NGXS_DEVTOOLS_OPTIONS, NgxsReduxDevtoolsPlugin, NgxsReduxDevtoolsPluginModule }; //# sourceMappingURL=ngxs-devtools-plugin.js.map",
  "map": null,
  "metadata": {},
  "sourceType": "module"
}
