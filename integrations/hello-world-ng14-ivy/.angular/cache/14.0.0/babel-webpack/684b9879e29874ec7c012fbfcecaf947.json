{
  "ast": null,
  "code": "import * as i0 from '@angular/core';\nimport { NgZone, PLATFORM_ID, Injectable, Inject, InjectionToken, inject, INJECTOR, ɵglobal, ErrorHandler, Optional, SkipSelf, NgModule, APP_BOOTSTRAP_LISTENER } from '@angular/core';\nimport * as i5 from '@ngxs/store/internals';\nimport { memoize, INITIAL_STATE_TOKEN, NgxsBootstrapper, ɵNGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY } from '@ngxs/store/internals';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, Subject, BehaviorSubject, of, forkJoin, throwError, EMPTY, from, isObservable } from 'rxjs';\nimport { filter, map, share, shareReplay, take, exhaustMap, mergeMap, defaultIfEmpty, catchError, takeUntil, distinctUntilChanged, tap, startWith, pairwise } from 'rxjs/operators';\n/**\n * Returns the type from an action instance/class.\n * @ignore\n */\n\nfunction getActionTypeFromInstance(action) {\n  if (action.constructor && action.constructor.type) {\n    return action.constructor.type;\n  } else {\n    return action.type;\n  }\n}\n/**\n * Matches a action\n * @ignore\n */\n\n\nfunction actionMatcher(action1) {\n  const type1 = getActionTypeFromInstance(action1);\n  return function (action2) {\n    return type1 === getActionTypeFromInstance(action2);\n  };\n}\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n */\n\n\nconst setValue = (obj, prop, val) => {\n  obj = Object.assign({}, obj);\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);\n    }\n\n    return acc && acc[part];\n  }, obj);\n  return obj;\n};\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\n\n\nconst getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc && acc[part], obj);\n/**\n * Simple object check.\n *\n *    isObject({a:1}) //=> true\n *    isObject(1) //=> false\n *\n * @ignore\n */\n\n\nconst isObject$1 = item => {\n  return item && typeof item === 'object' && !Array.isArray(item);\n};\n/**\n * Deep merge two objects.\n *\n *    mergeDeep({a:1, b:{x: 1, y:2}}, {b:{x: 3}, c:4}) //=> {a:1, b:{x:3, y:2}, c:4}\n *\n * @param base base object onto which `sources` will be applied\n */\n\n\nconst mergeDeep = (base, ...sources) => {\n  if (!sources.length) return base;\n  const source = sources.shift();\n\n  if (isObject$1(base) && isObject$1(source)) {\n    for (const key in source) {\n      if (isObject$1(source[key])) {\n        if (!base[key]) Object.assign(base, {\n          [key]: {}\n        });\n        mergeDeep(base[key], source[key]);\n      } else {\n        Object.assign(base, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n\n  return mergeDeep(base, ...sources);\n};\n\nfunction throwStateNameError(name) {\n  throw new Error(`${name} is not a valid state name. It needs to be a valid object property name.`);\n}\n\nfunction throwStateNamePropertyError() {\n  throw new Error(`States must register a 'name' property.`);\n}\n\nfunction throwStateUniqueError(current, newName, oldName) {\n  throw new Error(`State name '${current}' from ${newName} already exists in ${oldName}.`);\n}\n\nfunction throwStateDecoratorError(name) {\n  throw new Error(`States must be decorated with @State() decorator, but \"${name}\" isn't.`);\n}\n\nfunction throwActionDecoratorError() {\n  throw new Error('@Action() decorator cannot be used with static methods.');\n}\n\nfunction throwSelectorDecoratorError() {\n  throw new Error('Selectors only work on methods.');\n}\n\nfunction getZoneWarningMessage() {\n  return 'Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\\n' + 'Please set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\\n' + 'NgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })';\n}\n\nfunction getUndecoratedStateInIvyWarningMessage(name) {\n  return `'${name}' class should be decorated with @Injectable() right after the @State() decorator`;\n}\n\nfunction throwSelectFactoryNotConnectedError() {\n  throw new Error('You have forgotten to import the NGXS module!');\n}\n\nfunction throwPatchingArrayError() {\n  throw new Error('Patching arrays is not supported.');\n}\n\nfunction throwPatchingPrimitiveError() {\n  throw new Error('Patching primitives is not supported.');\n}\n\nclass DispatchOutsideZoneNgxsExecutionStrategy {\n  constructor(_ngZone, _platformId) {\n    this._ngZone = _ngZone;\n    this._platformId = _platformId; // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      verifyZoneIsNotNooped(_ngZone);\n    }\n  }\n\n  enter(func) {\n    if (isPlatformServer(this._platformId)) {\n      return this.runInsideAngular(func);\n    }\n\n    return this.runOutsideAngular(func);\n  }\n\n  leave(func) {\n    return this.runInsideAngular(func);\n  }\n\n  runInsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return func();\n    }\n\n    return this._ngZone.run(func);\n  }\n\n  runOutsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return this._ngZone.runOutsideAngular(func);\n    }\n\n    return func();\n  }\n\n}\n/** @nocollapse */\n\n\nDispatchOutsideZoneNgxsExecutionStrategy.ɵfac = function DispatchOutsideZoneNgxsExecutionStrategy_Factory(t) {\n  return new (t || DispatchOutsideZoneNgxsExecutionStrategy)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PLATFORM_ID));\n};\n/** @nocollapse */\n\n\nDispatchOutsideZoneNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DispatchOutsideZoneNgxsExecutionStrategy,\n  factory: DispatchOutsideZoneNgxsExecutionStrategy.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DispatchOutsideZoneNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})(); // Caretaker note: this should exist as a separate function and not a class method,\n// since class methods are not tree-shakable.\n\n\nfunction verifyZoneIsNotNooped(ngZone) {\n  // `NoopNgZone` is not exposed publicly as it doesn't expect\n  // to be used outside of the core Angular code, thus we just have\n  // to check if the zone doesn't extend or instanceof `NgZone`.\n  if (ngZone instanceof NgZone) {\n    return;\n  }\n\n  console.warn(getZoneWarningMessage());\n}\n\nconst ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');\nconst ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');\nconst FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');\nconst NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');\nconst META_KEY = 'NGXS_META';\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\nconst SELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n/**\n * The NGXS config settings.\n */\n\nclass NgxsConfig {\n  constructor() {\n    /**\n     * Defining the default state before module initialization\n     * This is convenient if we need to create a define our own set of states.\n     * @deprecated will be removed after v4\n     * (default: {})\n     */\n    this.defaultsState = {};\n    /**\n     * Defining shared selector options\n     */\n\n    this.selectorOptions = {\n      injectContainerState: true,\n      suppressErrors: true // TODO: default is true in v3, will change in v4\n\n    };\n    this.compatibility = {\n      strictContentSecurityPolicy: false\n    };\n    this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;\n  }\n\n}\n/** @nocollapse */\n\n\nNgxsConfig.ɵfac = function NgxsConfig_Factory(t) {\n  return new (t || NgxsConfig)();\n};\n/** @nocollapse */\n\n\nNgxsConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxsConfig,\n  factory: function NgxsConfig_Factory(t) {\n    let r = null;\n\n    if (t) {\n      r = new t();\n    } else {\n      r = (options => mergeDeep(new NgxsConfig(), options))(i0.ɵɵinject(ROOT_OPTIONS));\n    }\n\n    return r;\n  },\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root',\n      useFactory: options => mergeDeep(new NgxsConfig(), options),\n      deps: [ROOT_OPTIONS]\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n */\n\n\nclass NgxsSimpleChange {\n  constructor(previousValue, currentValue, firstChange) {\n    this.previousValue = previousValue;\n    this.currentValue = currentValue;\n    this.firstChange = firstChange;\n  }\n\n}\n\nclass NoopNgxsExecutionStrategy {\n  enter(func) {\n    return func();\n  }\n\n  leave(func) {\n    return func();\n  }\n\n}\n/** @nocollapse */\n\n\nNoopNgxsExecutionStrategy.ɵfac = function NoopNgxsExecutionStrategy_Factory(t) {\n  return new (t || NoopNgxsExecutionStrategy)();\n};\n/** @nocollapse */\n\n\nNoopNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NoopNgxsExecutionStrategy,\n  factory: NoopNgxsExecutionStrategy.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NoopNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\n * The strategy that might be provided by users through `options.executionStrategy`.\n */\n\n\nconst USER_PROVIDED_NGXS_EXECUTION_STRATEGY = new InjectionToken('USER_PROVIDED_NGXS_EXECUTION_STRATEGY');\n/*\n * Internal execution strategy injection token\n */\n\nconst NGXS_EXECUTION_STRATEGY = new InjectionToken('NGXS_EXECUTION_STRATEGY', {\n  providedIn: 'root',\n  factory: () => {\n    const injector = inject(INJECTOR);\n    const executionStrategy = injector.get(USER_PROVIDED_NGXS_EXECUTION_STRATEGY);\n    return executionStrategy ? injector.get(executionStrategy) : injector.get(typeof ɵglobal.Zone !== 'undefined' ? DispatchOutsideZoneNgxsExecutionStrategy : NoopNgxsExecutionStrategy);\n  }\n});\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n */\n\nfunction ensureStoreMetadata$1(target) {\n  if (!target.hasOwnProperty(META_KEY)) {\n    const defaultMetadata = {\n      name: null,\n      actions: {},\n      defaults: {},\n      path: null,\n\n      makeRootSelector(context) {\n        return context.getStateGetter(defaultMetadata.name);\n      },\n\n      children: []\n    };\n    Object.defineProperty(target, META_KEY, {\n      value: defaultMetadata\n    });\n  }\n\n  return getStoreMetadata$1(target);\n}\n/**\n * Get the metadata attached to the state class if it exists.\n *\n * @ignore\n */\n\n\nfunction getStoreMetadata$1(target) {\n  return target[META_KEY];\n}\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n */\n\n\nfunction ensureSelectorMetadata$1(target) {\n  if (!target.hasOwnProperty(SELECTOR_META_KEY)) {\n    const defaultMetadata = {\n      makeRootSelector: null,\n      originalFn: null,\n      containerClass: null,\n      selectorName: null,\n      getSelectorOptions: () => ({})\n    };\n    Object.defineProperty(target, SELECTOR_META_KEY, {\n      value: defaultMetadata\n    });\n  }\n\n  return getSelectorMetadata$1(target);\n}\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n */\n\n\nfunction getSelectorMetadata$1(target) {\n  return target[SELECTOR_META_KEY];\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\n *\n * @ignore\n */\n\n\nfunction compliantPropGetter(paths) {\n  const copyOfPaths = paths.slice();\n  return obj => copyOfPaths.reduce((acc, part) => acc && acc[part], obj);\n}\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n */\n\n\nfunction fastPropGetter(paths) {\n  const segments = paths;\n  let seg = 'store.' + segments[0];\n  let i = 0;\n  const l = segments.length;\n  let expr = seg;\n\n  while (++i < l) {\n    expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n  }\n\n  const fn = new Function('store', 'return ' + expr + ';');\n  return fn;\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\n\n\nfunction propGetter(paths, config) {\n  if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {\n    return compliantPropGetter(paths);\n  } else {\n    return fastPropGetter(paths);\n  }\n}\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n */\n\n\nfunction buildGraph(stateClasses) {\n  const findName = stateClass => {\n    const meta = stateClasses.find(g => g === stateClass); // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !meta) {\n      throw new Error(`Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`);\n    }\n\n    return meta[META_KEY].name;\n  };\n\n  return stateClasses.reduce((result, stateClass) => {\n    const {\n      name,\n      children\n    } = stateClass[META_KEY];\n    result[name] = (children || []).map(findName);\n    return result;\n  }, {});\n}\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n */\n\n\nfunction nameToState(states) {\n  return states.reduce((result, stateClass) => {\n    const meta = stateClass[META_KEY];\n    result[meta.name] = stateClass;\n    return result;\n  }, {});\n}\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n */\n\n\nfunction findFullParentPath(obj, newObj = {}) {\n  const visit = (child, keyToFind) => {\n    for (const key in child) {\n      if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\n        const parent = visit(child, key);\n        return parent !== null ? `${parent}.${key}` : key;\n      }\n    }\n\n    return null;\n  };\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const parent = visit(obj, key);\n      newObj[key] = parent ? `${parent}.${key}` : key;\n    }\n  }\n\n  return newObj;\n}\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n */\n\n\nfunction topologicalSort(graph) {\n  const sorted = [];\n  const visited = {};\n\n  const visit = (name, ancestors = []) => {\n    if (!Array.isArray(ancestors)) {\n      ancestors = [];\n    }\n\n    ancestors.push(name);\n    visited[name] = true;\n    graph[name].forEach(dep => {\n      // Caretaker note: we have still left the `typeof` condition in order to avoid\n      // creating a breaking change for projects that still use the View Engine.\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && ancestors.indexOf(dep) >= 0) {\n        throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\n      }\n\n      if (visited[dep]) {\n        return;\n      }\n\n      visit(dep, ancestors.slice(0));\n    });\n\n    if (sorted.indexOf(name) < 0) {\n      sorted.push(name);\n    }\n  };\n\n  Object.keys(graph).forEach(k => visit(k));\n  return sorted.reverse();\n}\n/**\n * Returns if the parameter is a object or not.\n *\n * @ignore\n */\n\n\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null || typeof obj === 'function';\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n */\n\n\nfunction ofAction(...allowedTypes) {\n  return ofActionOperator(allowedTypes);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n */\n\n\nfunction ofActionDispatched(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"DISPATCHED\"\n  /* Dispatched */\n  ]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n */\n\n\nfunction ofActionSuccessful(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"SUCCESSFUL\"\n  /* Successful */\n  ]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n */\n\n\nfunction ofActionCanceled(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"CANCELED\"\n  /* Canceled */\n  ]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been completed\n */\n\n\nfunction ofActionCompleted(...allowedTypes) {\n  const allowedStatuses = [\"SUCCESSFUL\"\n  /* Successful */\n  , \"CANCELED\"\n  /* Canceled */\n  , \"ERRORED\"\n  /* Errored */\n  ];\n  return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n */\n\n\nfunction ofActionErrored(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"ERRORED\"\n  /* Errored */\n  ]);\n}\n\nfunction ofActionOperator(allowedTypes, statuses, // This actually could've been `OperatorFunction<ActionContext, ActionCompletion | any>`,\n// since it maps either to `ctx.action` OR to `ActionCompletion`. But `ActionCompleteion | any`\n// defaults to `any`, thus there is no sense from union type.\nmapOperator = mapAction) {\n  const allowedMap = createAllowedActionTypesMap(allowedTypes);\n  const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\n  return function (o) {\n    return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());\n  };\n}\n\nfunction filterStatus(allowedTypes, allowedStatuses) {\n  return filter(ctx => {\n    const actionType = getActionTypeFromInstance(ctx.action);\n    const typeMatch = allowedTypes[actionType];\n    const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\n    return typeMatch && statusMatch;\n  });\n}\n\nfunction mapActionResult() {\n  return map(({\n    action,\n    status,\n    error\n  }) => {\n    return {\n      action,\n      result: {\n        successful: \"SUCCESSFUL\"\n        /* Successful */\n        === status,\n        canceled: \"CANCELED\"\n        /* Canceled */\n        === status,\n        error\n      }\n    };\n  });\n}\n\nfunction mapAction() {\n  return map(ctx => ctx.action);\n}\n\nfunction createAllowedActionTypesMap(types) {\n  return types.reduce((filterMap, klass) => {\n    filterMap[getActionTypeFromInstance(klass)] = true;\n    return filterMap;\n  }, {});\n}\n\nfunction createAllowedStatusesMap(statuses) {\n  return statuses.reduce((filterMap, status) => {\n    filterMap[status] = true;\n    return filterMap;\n  }, {});\n}\n/**\n * Returns operator that will run\n * `subscribe` outside of the ngxs execution context\n */\n\n\nfunction leaveNgxs(ngxsExecutionStrategy) {\n  return source => {\n    return new Observable(sink => {\n      return source.subscribe({\n        next(value) {\n          ngxsExecutionStrategy.leave(() => sink.next(value));\n        },\n\n        error(error) {\n          ngxsExecutionStrategy.leave(() => sink.error(error));\n        },\n\n        complete() {\n          ngxsExecutionStrategy.leave(() => sink.complete());\n        }\n\n      });\n    });\n  };\n}\n\nclass InternalNgxsExecutionStrategy {\n  constructor(_executionStrategy) {\n    this._executionStrategy = _executionStrategy;\n  }\n\n  enter(func) {\n    return this._executionStrategy.enter(func);\n  }\n\n  leave(func) {\n    return this._executionStrategy.leave(func);\n  }\n\n}\n/** @nocollapse */\n\n\nInternalNgxsExecutionStrategy.ɵfac = function InternalNgxsExecutionStrategy_Factory(t) {\n  return new (t || InternalNgxsExecutionStrategy)(i0.ɵɵinject(NGXS_EXECUTION_STRATEGY));\n};\n/** @nocollapse */\n\n\nInternalNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalNgxsExecutionStrategy,\n  factory: InternalNgxsExecutionStrategy.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_EXECUTION_STRATEGY]\n      }]\n    }];\n  }, null);\n})();\n/**\n * This wraps the provided function, and will enforce the following:\n * - The calls will execute in the order that they are made\n * - A call will only be initiated when the previous call has completed\n * - If there is a call currently executing then the new call will be added\n *   to the queue and the function will return immediately\n *\n * NOTE: The following assumptions about the operation must hold true:\n * - The operation is synchronous in nature\n * - If any asynchronous side effects of the call exist, it should not\n *   have any bearing on the correctness of the next call in the queue\n * - The operation has a void return\n * - The caller should not assume that the call has completed upon\n *   return of the function\n * - The caller can assume that all the queued calls will complete\n *   within the current microtask\n * - The only way that a call will encounter another call in the queue\n *   would be if the call at the front of the queue initiated this call\n *   as part of its synchronous execution\n */\n\n\nfunction orderedQueueOperation(operation) {\n  const callsQueue = [];\n  let busyPushingNext = false;\n  return function callOperation(...args) {\n    if (busyPushingNext) {\n      callsQueue.unshift(args);\n      return;\n    }\n\n    busyPushingNext = true;\n    operation(...args);\n\n    while (callsQueue.length > 0) {\n      const nextCallArgs = callsQueue.pop();\n      nextCallArgs && operation(...nextCallArgs);\n    }\n\n    busyPushingNext = false;\n  };\n}\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\n\n\nclass OrderedSubject extends Subject {\n  constructor() {\n    super(...arguments);\n    this._orderedNext = orderedQueueOperation(value => super.next(value));\n  }\n\n  next(value) {\n    this._orderedNext(value);\n  }\n\n}\n/**\n * Custom BehaviorSubject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard BehaviorSubject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new BehaviorSubject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `BehaviorSubject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedBehaviorSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\n\n\nclass OrderedBehaviorSubject extends BehaviorSubject {\n  constructor(value) {\n    super(value);\n    this._orderedNext = orderedQueueOperation(value => super.next(value));\n    this._currentValue = value;\n  }\n\n  getValue() {\n    return this._currentValue;\n  }\n\n  next(value) {\n    this._currentValue = value;\n\n    this._orderedNext(value);\n  }\n\n}\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\n\n\nclass InternalActions extends OrderedSubject {\n  ngOnDestroy() {\n    this.complete();\n  }\n\n}\n/** @nocollapse */\n\n\nInternalActions.ɵfac = /* @__PURE__ */function () {\n  let ɵInternalActions_BaseFactory;\n  return function InternalActions_Factory(t) {\n    return (ɵInternalActions_BaseFactory || (ɵInternalActions_BaseFactory = i0.ɵɵgetInheritedFactory(InternalActions)))(t || InternalActions);\n  };\n}();\n/** @nocollapse */\n\n\nInternalActions.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalActions,\n  factory: InternalActions.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalActions, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\n\n\nclass Actions extends Observable {\n  constructor(internalActions$, internalExecutionStrategy) {\n    const sharedInternalActions$ = internalActions$.pipe(leaveNgxs(internalExecutionStrategy), // The `InternalActions` subject emits outside of the Angular zone.\n    // We have to re-enter the Angular zone for any incoming consumer.\n    // The `share()` operator reduces the number of change detections.\n    // This would call leave only once for any stream emission across all active subscribers.\n    share());\n    super(observer => {\n      const childSubscription = sharedInternalActions$.subscribe({\n        next: ctx => observer.next(ctx),\n        error: error => observer.error(error),\n        complete: () => observer.complete()\n      });\n      observer.add(childSubscription);\n    });\n  }\n\n}\n/** @nocollapse */\n\n\nActions.ɵfac = function Actions_Factory(t) {\n  return new (t || Actions)(i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalNgxsExecutionStrategy));\n};\n/** @nocollapse */\n\n\nActions.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: Actions,\n  factory: Actions.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Actions, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: InternalActions\n    }, {\n      type: InternalNgxsExecutionStrategy\n    }];\n  }, null);\n})();\n/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n *\n * @ignore\n */\n\n\nconst compose = funcs => (...args) => {\n  const curr = funcs.shift();\n  return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));\n};\n/**\n * This operator is used for piping the observable result\n * from the `dispatch()`. It has a \"smart\" error handling\n * strategy that allows us to decide whether we propagate\n * errors to Angular's `ErrorHandler` or enable users to\n * handle them manually. We consider following cases:\n * 1) `store.dispatch()` (no subscribe) -> call `handleError()`\n * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`\n * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`\n * 4) `toPromise()` without `catch` -> do `handleError()`\n * 5) `toPromise()` with `catch` -> don't `handleError()`\n */\n\n\nfunction ngxsErrorHandler(internalErrorReporter, ngxsExecutionStrategy) {\n  return source => {\n    let subscribed = false;\n    source.subscribe({\n      error: error => {\n        // Do not trigger change detection for a microtask. This depends on the execution\n        // strategy being used, but the default `DispatchOutsideZoneNgxsExecutionStrategy`\n        // leaves the Angular zone.\n        ngxsExecutionStrategy.enter(() => Promise.resolve().then(() => {\n          if (!subscribed) {\n            ngxsExecutionStrategy.leave(() => internalErrorReporter.reportErrorSafely(error));\n          }\n        }));\n      }\n    });\n    return new Observable(subscriber => {\n      subscribed = true;\n      return source.pipe(leaveNgxs(ngxsExecutionStrategy)).subscribe(subscriber);\n    });\n  };\n}\n\nclass InternalErrorReporter {\n  constructor(_injector) {\n    this._injector = _injector;\n    /** Will be set lazily to be backward compatible. */\n\n    this._errorHandler = null;\n  }\n\n  reportErrorSafely(error) {\n    if (this._errorHandler === null) {\n      this._errorHandler = this._injector.get(ErrorHandler);\n    } // The `try-catch` is used to avoid handling the error twice. Suppose we call\n    // `handleError` which re-throws the error internally. The re-thrown error will\n    // be caught by zone.js which will then get to the `zone.onError.emit()` and the\n    // `onError` subscriber will call `handleError` again.\n\n\n    try {\n      this._errorHandler.handleError(error);\n    } catch (_a) {}\n  }\n\n}\n/** @nocollapse */\n\n\nInternalErrorReporter.ɵfac = function InternalErrorReporter_Factory(t) {\n  return new (t || InternalErrorReporter)(i0.ɵɵinject(i0.Injector));\n};\n/** @nocollapse */\n\n\nInternalErrorReporter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalErrorReporter,\n  factory: InternalErrorReporter.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalErrorReporter, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.Injector\n    }];\n  }, null);\n})();\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\n\n\nclass StateStream extends OrderedBehaviorSubject {\n  constructor() {\n    super({});\n  }\n\n  ngOnDestroy() {\n    // The `StateStream` should never emit values once the root view is removed, e.g. when the `NgModuleRef.destroy()` is called.\n    // This will eliminate memory leaks in server-side rendered apps where the `StateStream` is created per each HTTP request, users\n    // might forget to unsubscribe from `store.select` or `store.subscribe`, thus this will lead to huge memory leaks in SSR apps.\n    this.complete();\n  }\n\n}\n/** @nocollapse */\n\n\nStateStream.ɵfac = function StateStream_Factory(t) {\n  return new (t || StateStream)();\n};\n/** @nocollapse */\n\n\nStateStream.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateStream,\n  factory: StateStream.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateStream, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n\nclass PluginManager {\n  constructor(_parentManager, _pluginHandlers) {\n    this._parentManager = _parentManager;\n    this._pluginHandlers = _pluginHandlers;\n    this.plugins = [];\n    this.registerHandlers();\n  }\n\n  get rootPlugins() {\n    return this._parentManager && this._parentManager.plugins || this.plugins;\n  }\n\n  registerHandlers() {\n    const pluginHandlers = this.getPluginHandlers();\n    this.rootPlugins.push(...pluginHandlers);\n  }\n\n  getPluginHandlers() {\n    const handlers = this._pluginHandlers || [];\n    return handlers.map(plugin => plugin.handle ? plugin.handle.bind(plugin) : plugin);\n  }\n\n}\n/** @nocollapse */\n\n\nPluginManager.ɵfac = function PluginManager_Factory(t) {\n  return new (t || PluginManager)(i0.ɵɵinject(PluginManager, 12), i0.ɵɵinject(NGXS_PLUGINS, 8));\n};\n/** @nocollapse */\n\n\nPluginManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PluginManager,\n  factory: PluginManager.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PluginManager, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: PluginManager,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_PLUGINS]\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\n\n\nclass InternalDispatchedActionResults extends Subject {}\n/** @nocollapse */\n\n\nInternalDispatchedActionResults.ɵfac = /* @__PURE__ */function () {\n  let ɵInternalDispatchedActionResults_BaseFactory;\n  return function InternalDispatchedActionResults_Factory(t) {\n    return (ɵInternalDispatchedActionResults_BaseFactory || (ɵInternalDispatchedActionResults_BaseFactory = i0.ɵɵgetInheritedFactory(InternalDispatchedActionResults)))(t || InternalDispatchedActionResults);\n  };\n}();\n/** @nocollapse */\n\n\nInternalDispatchedActionResults.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalDispatchedActionResults,\n  factory: InternalDispatchedActionResults.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalDispatchedActionResults, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\nclass InternalDispatcher {\n  constructor(_actions, _actionResults, _pluginManager, _stateStream, _ngxsExecutionStrategy, _internalErrorReporter) {\n    this._actions = _actions;\n    this._actionResults = _actionResults;\n    this._pluginManager = _pluginManager;\n    this._stateStream = _stateStream;\n    this._ngxsExecutionStrategy = _ngxsExecutionStrategy;\n    this._internalErrorReporter = _internalErrorReporter;\n  }\n  /**\n   * Dispatches event(s).\n   */\n\n\n  dispatch(actionOrActions) {\n    const result = this._ngxsExecutionStrategy.enter(() => this.dispatchByEvents(actionOrActions));\n\n    return result.pipe(ngxsErrorHandler(this._internalErrorReporter, this._ngxsExecutionStrategy));\n  }\n\n  dispatchByEvents(actionOrActions) {\n    if (Array.isArray(actionOrActions)) {\n      if (actionOrActions.length === 0) return of(this._stateStream.getValue());\n      return forkJoin(actionOrActions.map(action => this.dispatchSingle(action)));\n    } else {\n      return this.dispatchSingle(actionOrActions);\n    }\n  }\n\n  dispatchSingle(action) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const type = getActionTypeFromInstance(action);\n\n      if (!type) {\n        const error = new Error(`This action doesn't have a type property: ${action.constructor.name}`);\n        return throwError(error);\n      }\n    }\n\n    const prevState = this._stateStream.getValue();\n\n    const plugins = this._pluginManager.plugins;\n    return compose([...plugins, (nextState, nextAction) => {\n      if (nextState !== prevState) {\n        this._stateStream.next(nextState);\n      }\n\n      const actionResult$ = this.getActionResultStream(nextAction);\n      actionResult$.subscribe(ctx => this._actions.next(ctx));\n\n      this._actions.next({\n        action: nextAction,\n        status: \"DISPATCHED\"\n        /* Dispatched */\n\n      });\n\n      return this.createDispatchObservable(actionResult$);\n    }])(prevState, action).pipe(shareReplay());\n  }\n\n  getActionResultStream(action) {\n    return this._actionResults.pipe(filter(ctx => ctx.action === action && ctx.status !== \"DISPATCHED\"\n    /* Dispatched */\n    ), take(1), shareReplay());\n  }\n\n  createDispatchObservable(actionResult$) {\n    return actionResult$.pipe(exhaustMap(ctx => {\n      switch (ctx.status) {\n        case \"SUCCESSFUL\"\n        /* Successful */\n        :\n          return of(this._stateStream.getValue());\n\n        case \"ERRORED\"\n        /* Errored */\n        :\n          return throwError(ctx.error);\n\n        default:\n          return EMPTY;\n      }\n    })).pipe(shareReplay());\n  }\n\n}\n/** @nocollapse */\n\n\nInternalDispatcher.ɵfac = function InternalDispatcher_Factory(t) {\n  return new (t || InternalDispatcher)(i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalDispatchedActionResults), i0.ɵɵinject(PluginManager), i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalNgxsExecutionStrategy), i0.ɵɵinject(InternalErrorReporter));\n};\n/** @nocollapse */\n\n\nInternalDispatcher.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalDispatcher,\n  factory: InternalDispatcher.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalDispatcher, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: InternalActions\n    }, {\n      type: InternalDispatchedActionResults\n    }, {\n      type: PluginManager\n    }, {\n      type: StateStream\n    }, {\n      type: InternalNgxsExecutionStrategy\n    }, {\n      type: InternalErrorReporter\n    }];\n  }, null);\n})();\n/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n */\n\n\nconst deepFreeze = o => {\n  Object.freeze(o);\n  const oIsFunction = typeof o === 'function';\n  const hasOwnProp = Object.prototype.hasOwnProperty;\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\n    if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  return o;\n};\n/**\n * @ignore\n */\n\n\nclass InternalStateOperations {\n  constructor(_stateStream, _dispatcher, _config) {\n    this._stateStream = _stateStream;\n    this._dispatcher = _dispatcher;\n    this._config = _config;\n  }\n  /**\n   * Returns the root state operators.\n   */\n\n\n  getRootStateOperations() {\n    const rootStateOperations = {\n      getState: () => this._stateStream.getValue(),\n      setState: newState => this._stateStream.next(newState),\n      dispatch: actionOrActions => this._dispatcher.dispatch(actionOrActions)\n    };\n\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      return this._config.developmentMode ? ensureStateAndActionsAreImmutable(rootStateOperations) : rootStateOperations;\n    } else {\n      return rootStateOperations;\n    }\n  }\n\n  setStateToTheCurrentWithNew(results) {\n    const stateOperations = this.getRootStateOperations(); // Get our current stream\n\n    const currentState = stateOperations.getState(); // Set the state to the current + new\n\n    stateOperations.setState(Object.assign(Object.assign({}, currentState), results.defaults));\n  }\n\n}\n/** @nocollapse */\n\n\nInternalStateOperations.ɵfac = function InternalStateOperations_Factory(t) {\n  return new (t || InternalStateOperations)(i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalDispatcher), i0.ɵɵinject(NgxsConfig));\n};\n/** @nocollapse */\n\n\nInternalStateOperations.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalStateOperations,\n  factory: InternalStateOperations.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalStateOperations, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: StateStream\n    }, {\n      type: InternalDispatcher\n    }, {\n      type: NgxsConfig\n    }];\n  }, null);\n})();\n\nfunction ensureStateAndActionsAreImmutable(root) {\n  return {\n    getState: () => root.getState(),\n    setState: value => {\n      const frozenValue = deepFreeze(value);\n      return root.setState(frozenValue);\n    },\n    dispatch: actions => {\n      return root.dispatch(actions);\n    }\n  };\n}\n\nfunction simplePatch(value) {\n  return existingState => {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (Array.isArray(value)) {\n        throwPatchingArrayError();\n      } else if (typeof value !== 'object') {\n        throwPatchingPrimitiveError();\n      }\n    }\n\n    const newState = Object.assign({}, existingState);\n\n    for (const key in value) {\n      // deep clone for patch compatibility\n      newState[key] = value[key];\n    }\n\n    return newState;\n  };\n}\n/**\n * State Context factory class\n * @ignore\n */\n\n\nclass StateContextFactory {\n  constructor(_internalStateOperations) {\n    this._internalStateOperations = _internalStateOperations;\n  }\n  /**\n   * Create the state context\n   */\n\n\n  createStateContext(mappedStore) {\n    const root = this._internalStateOperations.getRootStateOperations();\n\n    function getState(currentAppState) {\n      return getValue(currentAppState, mappedStore.path);\n    }\n\n    function setStateValue(currentAppState, newValue) {\n      const newAppState = setValue(currentAppState, mappedStore.path, newValue);\n      root.setState(newAppState);\n      return newAppState; // In doing this refactoring I noticed that there is a 'bug' where the\n      // application state is returned instead of this state slice.\n      // This has worked this way since the beginning see:\n      // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\n      // This needs to be fixed, but is a 'breaking' change.\n      // I will do this fix in a subsequent PR and we can decide how to handle it.\n    }\n\n    function setStateFromOperator(currentAppState, stateOperator) {\n      const local = getState(currentAppState);\n      const newValue = stateOperator(local);\n      return setStateValue(currentAppState, newValue);\n    }\n\n    function isStateOperator(value) {\n      return typeof value === 'function';\n    }\n\n    return {\n      getState() {\n        const currentAppState = root.getState();\n        return getState(currentAppState);\n      },\n\n      patchState(val) {\n        const currentAppState = root.getState();\n        const patchOperator = simplePatch(val);\n        return setStateFromOperator(currentAppState, patchOperator);\n      },\n\n      setState(val) {\n        const currentAppState = root.getState();\n        return isStateOperator(val) ? setStateFromOperator(currentAppState, val) : setStateValue(currentAppState, val);\n      },\n\n      dispatch(actions) {\n        return root.dispatch(actions);\n      }\n\n    };\n  }\n\n}\n/** @nocollapse */\n\n\nStateContextFactory.ɵfac = function StateContextFactory_Factory(t) {\n  return new (t || StateContextFactory)(i0.ɵɵinject(InternalStateOperations));\n};\n/** @nocollapse */\n\n\nStateContextFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateContextFactory,\n  factory: StateContextFactory.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateContextFactory, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: InternalStateOperations\n    }];\n  }, null);\n})();\n\nclass StoreValidators {\n  static checkThatStateIsNamedCorrectly(name) {\n    if (!name) {\n      throwStateNamePropertyError();\n    } else if (!this.stateNameRegex.test(name)) {\n      throwStateNameError(name);\n    }\n  }\n\n  static checkThatStateNameIsUnique(stateName, state, statesByName) {\n    const existingState = statesByName[stateName];\n\n    if (existingState && existingState !== state) {\n      throwStateUniqueError(stateName, state.name, existingState.name);\n    }\n  }\n\n  static checkThatStateClassesHaveBeenDecorated(stateClasses) {\n    stateClasses.forEach(stateClass => {\n      if (!getStoreMetadata$1(stateClass)) {\n        throwStateDecoratorError(stateClass.name);\n      }\n    });\n  }\n\n}\n\nStoreValidators.stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');\n/**\n * All provided or injected tokens must have `@Injectable` decorator\n * (previously, injected tokens without `@Injectable` were allowed\n * if another decorator was used, e.g. pipes).\n */\n\nfunction ensureStateClassIsInjectable(stateClass) {\n  if (jit_hasInjectableAnnotation(stateClass) || aot_hasNgInjectableDef(stateClass)) {\n    return;\n  }\n\n  console.warn(getUndecoratedStateInIvyWarningMessage(stateClass.name));\n}\n\nfunction aot_hasNgInjectableDef(stateClass) {\n  // `ɵprov` is a static property added by the NGCC compiler. It always exists in\n  // AOT mode because this property is added before runtime. If an application is running in\n  // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`\n  // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.\n  return !!stateClass.ɵprov;\n}\n\nfunction jit_hasInjectableAnnotation(stateClass) {\n  // `ɵprov` doesn't exist in JIT mode (for instance when running unit tests with Jest).\n  const annotations = stateClass.__annotations__ || [];\n  return annotations.some(annotation => (annotation === null || annotation === void 0 ? void 0 : annotation.ngMetadataName) === 'Injectable');\n}\n/**\n * Init action\n */\n\n\nclass InitState {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '@@INIT';\n  }\n\n}\n/**\n * Update action\n */\n\n\nclass UpdateState {\n  constructor(addedStates) {\n    this.addedStates = addedStates;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '@@UPDATE_STATE';\n  }\n\n}\n\nconst NGXS_DEVELOPMENT_OPTIONS = new InjectionToken('NGXS_DEVELOPMENT_OPTIONS', {\n  providedIn: 'root',\n  factory: () => ({\n    warnOnUnhandledActions: true\n  })\n});\n\nclass NgxsUnhandledActionsLogger {\n  constructor(options) {\n    /**\n     * These actions should be ignored by default; the user can increase this\n     * list in the future via the `ignoreActions` method.\n     */\n    this._ignoredActions = new Set([InitState.type, UpdateState.type]);\n\n    if (typeof options.warnOnUnhandledActions === 'object') {\n      this.ignoreActions(...options.warnOnUnhandledActions.ignore);\n    }\n  }\n  /**\n   * Adds actions to the internal list of actions that should be ignored.\n   */\n\n\n  ignoreActions(...actions) {\n    for (const action of actions) {\n      this._ignoredActions.add(action.type);\n    }\n  }\n  /** @internal */\n\n\n  warn(action) {\n    const actionShouldBeIgnored = Array.from(this._ignoredActions).some(type => type === getActionTypeFromInstance(action));\n\n    if (actionShouldBeIgnored) {\n      return;\n    }\n\n    action = action.constructor && action.constructor.name !== 'Object' ? action.constructor.name : action.type;\n    console.warn(`The ${action} action has been dispatched but hasn't been handled. This may happen if the state with an action handler for this action is not registered.`);\n  }\n\n}\n/** @nocollapse */\n\n\nNgxsUnhandledActionsLogger.ɵfac = function NgxsUnhandledActionsLogger_Factory(t) {\n  return new (t || NgxsUnhandledActionsLogger)(i0.ɵɵinject(NGXS_DEVELOPMENT_OPTIONS));\n};\n/** @nocollapse */\n\n\nNgxsUnhandledActionsLogger.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxsUnhandledActionsLogger,\n  factory: NgxsUnhandledActionsLogger.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsUnhandledActionsLogger, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_DEVELOPMENT_OPTIONS]\n      }]\n    }];\n  }, null);\n})();\n\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\n/**\n * The `StateFactory` class adds root and feature states to the graph.\n * This extracts state names from state classes, checks if they already\n * exist in the global graph, throws errors if their names are invalid, etc.\n * See its constructor, state factories inject state factories that are\n * parent-level providers. This is required to get feature states from the\n * injector on the same level.\n *\n * The `NgxsModule.forFeature(...)` returns `providers: [StateFactory, ...states]`.\n * The `StateFactory` is initialized on the feature level and goes through `...states`\n * to get them from the injector through `injector.get(state)`.\n * @ignore\n */\n\nclass StateFactory {\n  constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {\n    this._injector = _injector;\n    this._config = _config;\n    this._parentFactory = _parentFactory;\n    this._actions = _actions;\n    this._actionResults = _actionResults;\n    this._stateContextFactory = _stateContextFactory;\n    this._initialState = _initialState;\n    this._actionsSubscription = null;\n    this._states = [];\n    this._statesByName = {};\n    this._statePaths = {};\n    this.getRuntimeSelectorContext = memoize(() => {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const stateFactory = this;\n\n      function resolveGetter(key) {\n        const path = stateFactory.statePaths[key];\n        return path ? propGetter(path.split('.'), stateFactory._config) : null;\n      }\n\n      const context = this._parentFactory ? this._parentFactory.getRuntimeSelectorContext() : {\n        getStateGetter(key) {\n          let getter = resolveGetter(key);\n\n          if (getter) {\n            return getter;\n          }\n\n          return (...args) => {\n            // Late loaded getter\n            if (!getter) {\n              getter = resolveGetter(key);\n            }\n\n            return getter ? getter(...args) : undefined;\n          };\n        },\n\n        getSelectorOptions(localOptions) {\n          const globalSelectorOptions = stateFactory._config.selectorOptions;\n          return Object.assign(Object.assign({}, globalSelectorOptions), localOptions || {});\n        }\n\n      };\n      return context;\n    });\n  }\n\n  get states() {\n    return this._parentFactory ? this._parentFactory.states : this._states;\n  }\n\n  get statesByName() {\n    return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;\n  }\n\n  get statePaths() {\n    return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;\n  }\n\n  static cloneDefaults(defaults) {\n    let value = {};\n\n    if (Array.isArray(defaults)) {\n      value = defaults.slice();\n    } else if (isObject(defaults)) {\n      value = Object.assign({}, defaults);\n    } else if (defaults === undefined) {\n      value = {};\n    } else {\n      value = defaults;\n    }\n\n    return value;\n  }\n\n  ngOnDestroy() {\n    var _a;\n\n    (_a = this._actionsSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n  }\n  /**\n   * Add a new state to the global defs.\n   */\n\n\n  add(stateClasses) {\n    if (NG_DEV_MODE) {\n      StoreValidators.checkThatStateClassesHaveBeenDecorated(stateClasses);\n    }\n\n    const {\n      newStates\n    } = this.addToStatesMap(stateClasses);\n    if (!newStates.length) return [];\n    const stateGraph = buildGraph(newStates);\n    const sortedStates = topologicalSort(stateGraph);\n    const paths = findFullParentPath(stateGraph);\n    const nameGraph = nameToState(newStates);\n    const bootstrappedStores = [];\n\n    for (const name of sortedStates) {\n      const stateClass = nameGraph[name];\n      const path = paths[name];\n      const meta = stateClass[META_KEY];\n      this.addRuntimeInfoToMeta(meta, path); // Note: previously we called `ensureStateClassIsInjectable` within the\n      // `State` decorator. This check is moved here because the `ɵprov` property\n      // will not exist on the class in JIT mode (because it's set asynchronously\n      // during JIT compilation through `Object.defineProperty`).\n\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        ensureStateClassIsInjectable(stateClass);\n      }\n\n      const stateMap = {\n        name,\n        path,\n        isInitialised: false,\n        actions: meta.actions,\n        instance: this._injector.get(stateClass),\n        defaults: StateFactory.cloneDefaults(meta.defaults)\n      }; // ensure our store hasn't already been added\n      // but don't throw since it could be lazy\n      // loaded from different paths\n\n      if (!this.hasBeenMountedAndBootstrapped(name, path)) {\n        bootstrappedStores.push(stateMap);\n      }\n\n      this.states.push(stateMap);\n    }\n\n    return bootstrappedStores;\n  }\n  /**\n   * Add a set of states to the store and return the defaults\n   */\n\n\n  addAndReturnDefaults(stateClasses) {\n    const classes = stateClasses || [];\n    const mappedStores = this.add(classes);\n    const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});\n    return {\n      defaults,\n      states: mappedStores\n    };\n  }\n\n  connectActionHandlers() {\n    // Note: We have to connect actions only once when the `StateFactory`\n    //       is being created for the first time. This checks if we're in\n    //       a child state factory and the parent state factory already exists.\n    if (this._parentFactory || this._actionsSubscription !== null) {\n      return;\n    }\n\n    const dispatched$ = new Subject();\n    this._actionsSubscription = this._actions.pipe(filter(ctx => ctx.status === \"DISPATCHED\"\n    /* Dispatched */\n    ), mergeMap(ctx => {\n      dispatched$.next(ctx);\n      const action = ctx.action;\n      return this.invokeActions(dispatched$, action).pipe(map(() => ({\n        action,\n        status: \"SUCCESSFUL\"\n        /* Successful */\n\n      })), defaultIfEmpty({\n        action,\n        status: \"CANCELED\"\n        /* Canceled */\n\n      }), catchError(error => of({\n        action,\n        status: \"ERRORED\"\n        /* Errored */\n        ,\n        error\n      })));\n    })).subscribe(ctx => this._actionResults.next(ctx));\n  }\n  /**\n   * Invoke actions on the states.\n   */\n\n\n  invokeActions(dispatched$, action) {\n    const type = getActionTypeFromInstance(action);\n    const results = []; // Determines whether the dispatched action has been handled, this is assigned\n    // to `true` within the below `for` loop if any `actionMetas` has been found.\n\n    let actionHasBeenHandled = false;\n\n    for (const metadata of this.states) {\n      const actionMetas = metadata.actions[type];\n\n      if (actionMetas) {\n        for (const actionMeta of actionMetas) {\n          const stateContext = this._stateContextFactory.createStateContext(metadata);\n\n          try {\n            let result = metadata.instance[actionMeta.fn](stateContext, action);\n\n            if (result instanceof Promise) {\n              result = from(result);\n            }\n\n            if (isObservable(result)) {\n              // If this observable has been completed w/o emitting\n              // any value then we wouldn't want to complete the whole chain\n              // of actions. Since if any observable completes then\n              // action will be canceled.\n              // For instance if any action handler would've had such statement:\n              // `handler(ctx) { return EMPTY; }`\n              // then the action will be canceled.\n              // See https://github.com/ngxs/store/issues/1568\n              result = result.pipe(mergeMap(value => {\n                if (value instanceof Promise) {\n                  return from(value);\n                }\n\n                if (isObservable(value)) {\n                  return value;\n                }\n\n                return of(value);\n              }), defaultIfEmpty({}));\n\n              if (actionMeta.options.cancelUncompleted) {\n                // todo: ofActionDispatched should be used with action class\n                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(action))));\n              }\n            } else {\n              result = of({}).pipe(shareReplay());\n            }\n\n            results.push(result);\n          } catch (e) {\n            results.push(throwError(e));\n          }\n\n          actionHasBeenHandled = true;\n        }\n      }\n    } // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions\n    // only during development.\n\n\n    if (NG_DEV_MODE && !actionHasBeenHandled) {\n      const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null); // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the\n      // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`\n      // didn't return `null` so we may ensure the module has been imported.\n\n\n      if (unhandledActionsLogger) {\n        unhandledActionsLogger.warn(action);\n      }\n    }\n\n    if (!results.length) {\n      results.push(of({}));\n    }\n\n    return forkJoin(results);\n  }\n\n  addToStatesMap(stateClasses) {\n    const newStates = [];\n    const statesMap = this.statesByName;\n\n    for (const stateClass of stateClasses) {\n      const stateName = getStoreMetadata$1(stateClass).name;\n\n      if (NG_DEV_MODE) {\n        StoreValidators.checkThatStateNameIsUnique(stateName, stateClass, statesMap);\n      }\n\n      const unmountedState = !statesMap[stateName];\n\n      if (unmountedState) {\n        newStates.push(stateClass);\n        statesMap[stateName] = stateClass;\n      }\n    }\n\n    return {\n      newStates\n    };\n  }\n\n  addRuntimeInfoToMeta(meta, path) {\n    this.statePaths[meta.name] = path; // TODO: v4 - we plan to get rid of the path property because it is non-deterministic\n    // we can do this when we get rid of the incorrectly exposed getStoreMetadata\n    // We will need to come up with an alternative in v4 because this is used by many plugins\n\n    meta.path = path;\n  }\n\n  hasBeenMountedAndBootstrapped(name, path) {\n    const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined; // This checks whether a state has been already added to the global graph and\n    // its lifecycle is in 'bootstrapped' state.\n\n    return this.statesByName[name] && valueIsBootstrappedInInitialState;\n  }\n\n}\n/** @nocollapse */\n\n\nStateFactory.ɵfac = function StateFactory_Factory(t) {\n  return new (t || StateFactory)(i0.ɵɵinject(i0.Injector), i0.ɵɵinject(NgxsConfig), i0.ɵɵinject(StateFactory, 12), i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalDispatchedActionResults), i0.ɵɵinject(StateContextFactory), i0.ɵɵinject(INITIAL_STATE_TOKEN, 8));\n};\n/** @nocollapse */\n\n\nStateFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateFactory,\n  factory: StateFactory.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateFactory, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i0.Injector\n    }, {\n      type: NgxsConfig\n    }, {\n      type: StateFactory,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }, {\n      type: InternalActions\n    }, {\n      type: InternalDispatchedActionResults\n    }, {\n      type: StateContextFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [INITIAL_STATE_TOKEN]\n      }]\n    }];\n  }, null);\n})();\n\nfunction createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {\n  return context => {\n    const {\n      argumentSelectorFunctions,\n      selectorOptions\n    } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);\n    return function selectFromRoot(rootState) {\n      // Determine arguments from the app state using the selectors\n      const results = argumentSelectorFunctions.map(argFn => argFn(rootState)); // if the lambda tries to access a something on the\n      // state that doesn't exist, it will throw a TypeError.\n      // since this is quite usual behaviour, we simply return undefined if so.\n\n      try {\n        return memoizedSelectorFn(...results);\n      } catch (ex) {\n        if (ex instanceof TypeError && selectorOptions.suppressErrors) {\n          return undefined;\n        }\n\n        throw ex;\n      }\n    };\n  };\n}\n\nfunction createMemoizedSelectorFn(originalFn, creationMetadata) {\n  const containerClass = creationMetadata && creationMetadata.containerClass;\n\n  const wrappedFn = function wrappedSelectorFn(...args) {\n    const returnValue = originalFn.apply(containerClass, args);\n\n    if (returnValue instanceof Function) {\n      const innerMemoizedFn = memoize.apply(null, [returnValue]);\n      return innerMemoizedFn;\n    }\n\n    return returnValue;\n  };\n\n  const memoizedFn = memoize(wrappedFn);\n  Object.setPrototypeOf(memoizedFn, originalFn);\n  return memoizedFn;\n}\n\nfunction getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {\n  const localSelectorOptions = selectorMetaData.getSelectorOptions();\n  const selectorOptions = context.getSelectorOptions(localSelectorOptions);\n  const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);\n  const argumentSelectorFunctions = selectorsToApply.map(selector => {\n    const factory = getRootSelectorFactory(selector);\n    return factory(context);\n  });\n  return {\n    selectorOptions,\n    argumentSelectorFunctions\n  };\n}\n\nfunction getSelectorsToApply(selectors = [], selectorOptions, containerClass) {\n  const selectorsToApply = [];\n  const canInjectContainerState = selectors.length === 0 || selectorOptions.injectContainerState;\n\n  if (containerClass && canInjectContainerState) {\n    // If we are on a state class, add it as the first selector parameter\n    const metadata = getStoreMetadata$1(containerClass);\n\n    if (metadata) {\n      selectorsToApply.push(containerClass);\n    }\n  }\n\n  if (selectors) {\n    selectorsToApply.push(...selectors);\n  }\n\n  return selectorsToApply;\n}\n/**\n * This function gets the factory function to create the selector to get the selected slice from the app state\n * @ignore\n */\n\n\nfunction getRootSelectorFactory(selector) {\n  const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n  return metadata && metadata.makeRootSelector || (() => selector);\n} // tslint:disable:unified-signatures\n\n\nclass Store {\n  constructor(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {\n    this._stateStream = _stateStream;\n    this._internalStateOperations = _internalStateOperations;\n    this._config = _config;\n    this._internalExecutionStrategy = _internalExecutionStrategy;\n    this._stateFactory = _stateFactory;\n    /**\n     * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n     * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n     * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n     */\n\n    this._selectableStateStream = this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy), shareReplay({\n      bufferSize: 1,\n      refCount: true\n    }));\n    this.initStateStream(initialStateValue);\n  }\n  /**\n   * Dispatches event(s).\n   */\n\n\n  dispatch(actionOrActions) {\n    return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);\n  }\n\n  select(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return this._selectableStateStream.pipe(map(selectorFn), catchError(err => {\n      // if error is TypeError we swallow it to prevent usual errors with property access\n      const {\n        suppressErrors\n      } = this._config.selectorOptions;\n\n      if (err instanceof TypeError && suppressErrors) {\n        return of(undefined);\n      } // rethrow other errors\n\n\n      return throwError(err);\n    }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));\n  }\n\n  selectOnce(selector) {\n    return this.select(selector).pipe(take(1));\n  }\n\n  selectSnapshot(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return selectorFn(this._stateStream.getValue());\n  }\n  /**\n   * Allow the user to subscribe to the root of the state\n   */\n\n\n  subscribe(fn) {\n    return this._selectableStateStream.pipe(leaveNgxs(this._internalExecutionStrategy)).subscribe(fn);\n  }\n  /**\n   * Return the raw value of the state.\n   */\n\n\n  snapshot() {\n    return this._internalStateOperations.getRootStateOperations().getState();\n  }\n  /**\n   * Reset the state to a specific point in time. This method is useful\n   * for plugin's who need to modify the state directly or unit testing.\n   */\n\n\n  reset(state) {\n    return this._internalStateOperations.getRootStateOperations().setState(state);\n  }\n\n  getStoreBoundSelectorFn(selector) {\n    const makeSelectorFn = getRootSelectorFactory(selector);\n\n    const runtimeContext = this._stateFactory.getRuntimeSelectorContext();\n\n    return makeSelectorFn(runtimeContext);\n  }\n\n  initStateStream(initialStateValue) {\n    const value = this._stateStream.value;\n    const storeIsEmpty = !value || Object.keys(value).length === 0;\n\n    if (storeIsEmpty) {\n      const defaultStateNotEmpty = Object.keys(this._config.defaultsState).length > 0;\n      const storeValues = defaultStateNotEmpty ? Object.assign(Object.assign({}, this._config.defaultsState), initialStateValue) : initialStateValue;\n\n      this._stateStream.next(storeValues);\n    }\n  }\n\n}\n/** @nocollapse */\n\n\nStore.ɵfac = function Store_Factory(t) {\n  return new (t || Store)(i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(NgxsConfig), i0.ɵɵinject(InternalNgxsExecutionStrategy), i0.ɵɵinject(StateFactory), i0.ɵɵinject(INITIAL_STATE_TOKEN, 8));\n};\n/** @nocollapse */\n\n\nStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: Store,\n  factory: Store.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Store, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: StateStream\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: NgxsConfig\n    }, {\n      type: InternalNgxsExecutionStrategy\n    }, {\n      type: StateFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [INITIAL_STATE_TOKEN]\n      }]\n    }];\n  }, null);\n})();\n/**\n * Allows the select decorator to get access to the DI store, this is used internally\n * in `@Select` decorator.\n */\n\n\nclass SelectFactory {\n  constructor(store, config) {\n    SelectFactory.store = store;\n    SelectFactory.config = config;\n  }\n\n  ngOnDestroy() {\n    SelectFactory.store = null;\n    SelectFactory.config = null;\n  }\n\n}\n\nSelectFactory.store = null;\nSelectFactory.config = null;\n/** @nocollapse */\n\nSelectFactory.ɵfac = function SelectFactory_Factory(t) {\n  return new (t || SelectFactory)(i0.ɵɵinject(Store), i0.ɵɵinject(NgxsConfig));\n};\n/** @nocollapse */\n\n\nSelectFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SelectFactory,\n  factory: SelectFactory.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SelectFactory, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Store\n    }, {\n      type: NgxsConfig\n    }];\n  }, null);\n})();\n\nclass LifecycleStateManager {\n  constructor(_store, _internalErrorReporter, _internalStateOperations, _stateContextFactory, _bootstrapper) {\n    this._store = _store;\n    this._internalErrorReporter = _internalErrorReporter;\n    this._internalStateOperations = _internalStateOperations;\n    this._stateContextFactory = _stateContextFactory;\n    this._bootstrapper = _bootstrapper;\n    this._destroy$ = new Subject();\n  }\n\n  ngOnDestroy() {\n    this._destroy$.next();\n  }\n\n  ngxsBootstrap(action, results) {\n    this._internalStateOperations.getRootStateOperations().dispatch(action).pipe(filter(() => !!results), tap(() => this._invokeInitOnStates(results.states)), mergeMap(() => this._bootstrapper.appBootstrapped$), filter(appBootstrapped => !!appBootstrapped), catchError(error => {\n      // The `SafeSubscriber` (which is used by most RxJS operators) re-throws\n      // errors asynchronously (`setTimeout(() => { throw error })`). This might\n      // break existing user's code or unit tests. We catch the error manually to\n      // be backward compatible with the old behavior.\n      this._internalErrorReporter.reportErrorSafely(error);\n\n      return EMPTY;\n    }), takeUntil(this._destroy$)).subscribe(() => this._invokeBootstrapOnStates(results.states));\n  }\n\n  _invokeInitOnStates(mappedStores) {\n    for (const mappedStore of mappedStores) {\n      const instance = mappedStore.instance;\n\n      if (instance.ngxsOnChanges) {\n        this._store.select(state => getValue(state, mappedStore.path)).pipe(startWith(undefined), pairwise(), takeUntil(this._destroy$)).subscribe(([previousValue, currentValue]) => {\n          const change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);\n          instance.ngxsOnChanges(change);\n        });\n      }\n\n      if (instance.ngxsOnInit) {\n        instance.ngxsOnInit(this._getStateContext(mappedStore));\n      }\n\n      mappedStore.isInitialised = true;\n    }\n  }\n\n  _invokeBootstrapOnStates(mappedStores) {\n    for (const mappedStore of mappedStores) {\n      const instance = mappedStore.instance;\n\n      if (instance.ngxsAfterBootstrap) {\n        instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));\n      }\n    }\n  }\n\n  _getStateContext(mappedStore) {\n    return this._stateContextFactory.createStateContext(mappedStore);\n  }\n\n}\n/** @nocollapse */\n\n\nLifecycleStateManager.ɵfac = function LifecycleStateManager_Factory(t) {\n  return new (t || LifecycleStateManager)(i0.ɵɵinject(Store), i0.ɵɵinject(InternalErrorReporter), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(StateContextFactory), i0.ɵɵinject(i5.NgxsBootstrapper));\n};\n/** @nocollapse */\n\n\nLifecycleStateManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LifecycleStateManager,\n  factory: LifecycleStateManager.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LifecycleStateManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Store\n    }, {\n      type: InternalErrorReporter\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: StateContextFactory\n    }, {\n      type: i5.NgxsBootstrapper\n    }];\n  }, null);\n})();\n/**\n * Root module\n * @ignore\n */\n\n\nclass NgxsRootModule {\n  constructor(factory, internalStateOperations, _store, _select, states = [], lifecycleStateManager) {\n    // Add stores to the state graph and return their defaults\n    const results = factory.addAndReturnDefaults(states);\n    internalStateOperations.setStateToTheCurrentWithNew(results); // Connect our actions stream\n\n    factory.connectActionHandlers(); // Dispatch the init action and invoke init and bootstrap functions after\n\n    lifecycleStateManager.ngxsBootstrap(new InitState(), results);\n  }\n\n}\n/** @nocollapse */\n\n\nNgxsRootModule.ɵfac = function NgxsRootModule_Factory(t) {\n  return new (t || NgxsRootModule)(i0.ɵɵinject(StateFactory), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(Store), i0.ɵɵinject(SelectFactory), i0.ɵɵinject(ROOT_STATE_TOKEN, 8), i0.ɵɵinject(LifecycleStateManager));\n};\n/** @nocollapse */\n\n\nNgxsRootModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsRootModule\n});\n/** @nocollapse */\n\nNgxsRootModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsRootModule, [{\n    type: NgModule\n  }], function () {\n    return [{\n      type: StateFactory\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: Store\n    }, {\n      type: SelectFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [ROOT_STATE_TOKEN]\n      }]\n    }, {\n      type: LifecycleStateManager\n    }];\n  }, null);\n})();\n/**\n * Feature module\n * @ignore\n */\n\n\nclass NgxsFeatureModule {\n  constructor(_store, internalStateOperations, factory, states = [], lifecycleStateManager) {\n    // Since FEATURE_STATE_TOKEN is a multi token, we need to\n    // flatten it [[Feature1State, Feature2State], [Feature3State]]\n    const flattenedStates = NgxsFeatureModule.flattenStates(states); // add stores to the state graph and return their defaults\n\n    const results = factory.addAndReturnDefaults(flattenedStates);\n\n    if (results.states.length) {\n      internalStateOperations.setStateToTheCurrentWithNew(results); // dispatch the update action and invoke init and bootstrap functions after\n\n      lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);\n    }\n  }\n\n  static flattenStates(states = []) {\n    return states.reduce((total, values) => total.concat(values), []);\n  }\n\n}\n/** @nocollapse */\n\n\nNgxsFeatureModule.ɵfac = function NgxsFeatureModule_Factory(t) {\n  return new (t || NgxsFeatureModule)(i0.ɵɵinject(Store), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(StateFactory), i0.ɵɵinject(FEATURE_STATE_TOKEN, 8), i0.ɵɵinject(LifecycleStateManager));\n};\n/** @nocollapse */\n\n\nNgxsFeatureModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsFeatureModule\n});\n/** @nocollapse */\n\nNgxsFeatureModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsFeatureModule, [{\n    type: NgModule\n  }], function () {\n    return [{\n      type: Store\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: StateFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [FEATURE_STATE_TOKEN]\n      }]\n    }, {\n      type: LifecycleStateManager\n    }];\n  }, null);\n})();\n/**\n * Ngxs Module\n */\n\n\nclass NgxsModule {\n  /**\n   * Root module factory\n   */\n  static forRoot(states = [], options = {}) {\n    return {\n      ngModule: NgxsRootModule,\n      providers: [StateFactory, PluginManager, ...states, ...NgxsModule.ngxsTokenProviders(states, options)]\n    };\n  }\n  /**\n   * Feature module factory\n   */\n\n\n  static forFeature(states = []) {\n    return {\n      ngModule: NgxsFeatureModule,\n      providers: [// This is required on the feature level, see comments in `state-factory.ts`.\n      StateFactory, PluginManager, ...states, {\n        provide: FEATURE_STATE_TOKEN,\n        multi: true,\n        useValue: states\n      }]\n    };\n  }\n\n  static ngxsTokenProviders(states, options) {\n    return [{\n      provide: USER_PROVIDED_NGXS_EXECUTION_STRATEGY,\n      useValue: options.executionStrategy\n    }, {\n      provide: ROOT_STATE_TOKEN,\n      useValue: states\n    }, {\n      provide: ROOT_OPTIONS,\n      useValue: options\n    }, {\n      provide: APP_BOOTSTRAP_LISTENER,\n      useFactory: NgxsModule.appBootstrapListenerFactory,\n      multi: true,\n      deps: [NgxsBootstrapper]\n    }, {\n      provide: ɵNGXS_STATE_CONTEXT_FACTORY,\n      useExisting: StateContextFactory\n    }, {\n      provide: ɵNGXS_STATE_FACTORY,\n      useExisting: StateFactory\n    }];\n  }\n\n  static appBootstrapListenerFactory(bootstrapper) {\n    return () => bootstrapper.bootstrap();\n  }\n\n}\n/** @nocollapse */\n\n\nNgxsModule.ɵfac = function NgxsModule_Factory(t) {\n  return new (t || NgxsModule)();\n};\n/** @nocollapse */\n\n\nNgxsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsModule\n});\n/** @nocollapse */\n\nNgxsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsModule, [{\n    type: NgModule\n  }], null, null);\n})();\n/**\n * Decorates a method with a action information.\n */\n\n\nfunction Action(actions, options) {\n  return (target, name) => {\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const isStaticMethod = target.hasOwnProperty('prototype');\n\n      if (isStaticMethod) {\n        throwActionDecoratorError();\n      }\n    }\n\n    const meta = ensureStoreMetadata$1(target.constructor);\n\n    if (!Array.isArray(actions)) {\n      actions = [actions];\n    }\n\n    for (const action of actions) {\n      const type = action.type;\n\n      if (!meta.actions[type]) {\n        meta.actions[type] = [];\n      }\n\n      meta.actions[type].push({\n        fn: name,\n        options: options || {},\n        type\n      });\n    }\n  };\n}\n/**\n * Decorates a class with ngxs state information.\n */\n\n\nfunction State(options) {\n  function getStateOptions(inheritedStateClass) {\n    const inheritanceOptions = inheritedStateClass[META_OPTIONS_KEY] || {};\n    return Object.assign(Object.assign({}, inheritanceOptions), options);\n  }\n\n  function mutateMetaData(params) {\n    const {\n      meta,\n      inheritedStateClass,\n      optionsWithInheritance\n    } = params;\n    const {\n      children,\n      defaults,\n      name\n    } = optionsWithInheritance;\n    const stateName = typeof name === 'string' ? name : name && name.getName() || null; // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      StoreValidators.checkThatStateIsNamedCorrectly(stateName);\n    }\n\n    if (inheritedStateClass.hasOwnProperty(META_KEY)) {\n      const inheritedMeta = inheritedStateClass[META_KEY] || {};\n      meta.actions = Object.assign(Object.assign({}, meta.actions), inheritedMeta.actions);\n    }\n\n    meta.children = children;\n    meta.defaults = defaults;\n    meta.name = stateName;\n  }\n\n  return target => {\n    const stateClass = target;\n    const meta = ensureStoreMetadata$1(stateClass);\n    const inheritedStateClass = Object.getPrototypeOf(stateClass);\n    const optionsWithInheritance = getStateOptions(inheritedStateClass);\n    mutateMetaData({\n      meta,\n      inheritedStateClass,\n      optionsWithInheritance\n    });\n    stateClass[META_OPTIONS_KEY] = optionsWithInheritance;\n  };\n}\n\nconst DOLLAR_CHAR_CODE = 36;\n\nfunction createSelectObservable(selector) {\n  if (!SelectFactory.store) {\n    throwSelectFactoryNotConnectedError();\n  }\n\n  return SelectFactory.store.select(selector);\n}\n\nfunction createSelectorFn(name, rawSelector, paths = []) {\n  rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;\n\n  if (typeof rawSelector === 'string') {\n    const propsArray = paths.length ? [rawSelector, ...paths] : rawSelector.split('.');\n    return propGetter(propsArray, SelectFactory.config);\n  }\n\n  return rawSelector;\n}\n/**\n * @example If `foo$` => make it just `foo`\n */\n\n\nfunction removeDollarAtTheEnd(name) {\n  const lastCharIndex = name.length - 1;\n  const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\n  return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\n}\n/**\n * Decorator for selecting a slice of state from the store.\n */\n\n\nfunction Select(rawSelector, ...paths) {\n  return function (target, key) {\n    const name = key.toString();\n    const selectorId = `__${name}__selector`;\n    const selector = createSelectorFn(name, rawSelector, paths);\n    Object.defineProperties(target, {\n      [selectorId]: {\n        writable: true,\n        enumerable: false,\n        configurable: true\n      },\n      [name]: {\n        enumerable: true,\n        configurable: true,\n\n        get() {\n          return this[selectorId] || (this[selectorId] = createSelectObservable(selector));\n        }\n\n      }\n    });\n  };\n}\n\nconst SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';\nconst selectorOptionsMetaAccessor = {\n  getOptions: target => {\n    return target && target[SELECTOR_OPTIONS_META_KEY] || {};\n  },\n  defineOptions: (target, options) => {\n    if (!target) return;\n    target[SELECTOR_OPTIONS_META_KEY] = options;\n  }\n};\n\nfunction setupSelectorMetadata(originalFn, creationMetadata) {\n  const selectorMetaData = ensureSelectorMetadata$1(originalFn);\n  selectorMetaData.originalFn = originalFn;\n\n  let getExplicitSelectorOptions = () => ({});\n\n  if (creationMetadata) {\n    selectorMetaData.containerClass = creationMetadata.containerClass;\n    selectorMetaData.selectorName = creationMetadata.selectorName || null;\n    getExplicitSelectorOptions = creationMetadata.getSelectorOptions || getExplicitSelectorOptions;\n  }\n\n  const selectorMetaDataClone = Object.assign({}, selectorMetaData);\n\n  selectorMetaData.getSelectorOptions = () => getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());\n\n  return selectorMetaData;\n}\n\nfunction getLocalSelectorOptions(selectorMetaData, explicitOptions) {\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {}), selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {}), selectorMetaData.getSelectorOptions() || {}), explicitOptions);\n}\n/**\n * Decorator for setting selector options at a method or class level.\n */\n\n\nfunction SelectorOptions(options) {\n  return function decorate(target, methodName, descriptor) {\n    if (methodName) {\n      descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, methodName)); // Method Decorator\n\n      const originalFn = descriptor.value || descriptor.originalFn;\n\n      if (originalFn) {\n        selectorOptionsMetaAccessor.defineOptions(originalFn, options);\n      }\n    } else {\n      // Class Decorator\n      selectorOptionsMetaAccessor.defineOptions(target, options);\n    }\n  };\n}\n\nfunction ensureStoreMetadata(target) {\n  return ensureStoreMetadata$1(target);\n}\n\nfunction getStoreMetadata(target) {\n  return getStoreMetadata$1(target);\n}\n\nfunction ensureSelectorMetadata(target) {\n  return ensureSelectorMetadata$1(target);\n}\n\nfunction getSelectorMetadata(target) {\n  return getSelectorMetadata$1(target);\n}\n\nfunction createSelector(selectors, projector, creationMetadata) {\n  const memoizedFn = createMemoizedSelectorFn(projector, creationMetadata);\n  const selectorMetaData = setupSelectorMetadata(projector, creationMetadata);\n  selectorMetaData.makeRootSelector = createRootSelectorFactory(selectorMetaData, selectors, memoizedFn);\n  return memoizedFn;\n}\n\nfunction Selector(selectors) {\n  return (target, key, descriptor) => {\n    descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, key));\n    const originalFn = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value; // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (originalFn && typeof originalFn !== 'function') {\n        throwSelectorDecoratorError();\n      }\n    }\n\n    const memoizedFn = createSelector(selectors, originalFn, {\n      containerClass: target,\n      selectorName: key.toString(),\n\n      getSelectorOptions() {\n        return {};\n      }\n\n    });\n    const newDescriptor = {\n      configurable: true,\n\n      get() {\n        return memoizedFn;\n      }\n\n    }; // Add hidden property to descriptor\n\n    newDescriptor['originalFn'] = originalFn;\n    return newDescriptor;\n  };\n}\n\nclass StateToken {\n  constructor(name) {\n    this.name = name;\n    const selectorMetadata = ensureSelectorMetadata$1(this);\n\n    selectorMetadata.makeRootSelector = runtimeContext => {\n      return runtimeContext.getStateGetter(this.name);\n    };\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  toString() {\n    return `StateToken[${this.name}]`;\n  }\n\n}\n\nclass NgxsDevelopmentModule {\n  static forRoot(options) {\n    return {\n      ngModule: NgxsDevelopmentModule,\n      providers: [NgxsUnhandledActionsLogger, {\n        provide: NGXS_DEVELOPMENT_OPTIONS,\n        useValue: options\n      }]\n    };\n  }\n\n}\n/** @nocollapse */\n\n\nNgxsDevelopmentModule.ɵfac = function NgxsDevelopmentModule_Factory(t) {\n  return new (t || NgxsDevelopmentModule)();\n};\n/** @nocollapse */\n\n\nNgxsDevelopmentModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsDevelopmentModule\n});\n/** @nocollapse */\n\nNgxsDevelopmentModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsDevelopmentModule, [{\n    type: NgModule\n  }], null, null);\n})();\n\nfunction ensureValidSelector(selector, context = {}) {\n  const noun = context.noun || 'selector';\n  const prefix = context.prefix ? context.prefix + ': ' : '';\n  ensureValueProvided(selector, {\n    noun,\n    prefix: context.prefix\n  });\n  const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n\n  if (!metadata) {\n    throw new Error(`${prefix}The value provided as the ${noun} is not a valid selector.`);\n  }\n}\n\nfunction ensureValueProvided(value, context = {}) {\n  const noun = context.noun || 'value';\n  const prefix = context.prefix ? context.prefix + ': ' : '';\n\n  if (!value) {\n    throw new Error(`${prefix}A ${noun} must be provided.`);\n  }\n}\n\nfunction createModelSelector(selectorMap) {\n  const selectorKeys = Object.keys(selectorMap);\n  const selectors = Object.values(selectorMap);\n  ensureValidSelectorMap({\n    prefix: '[createModelSelector]',\n    selectorMap,\n    selectorKeys,\n    selectors\n  });\n  return createSelector(selectors, (...args) => {\n    return selectorKeys.reduce((obj, key, index) => {\n      obj[key] = args[index];\n      return obj;\n    }, {});\n  });\n}\n\nfunction ensureValidSelectorMap({\n  prefix,\n  selectorMap,\n  selectorKeys,\n  selectors\n}) {\n  ensureValueProvided(selectorMap, {\n    prefix,\n    noun: 'selector map'\n  });\n  ensureValueProvided(typeof selectorMap === 'object', {\n    prefix,\n    noun: 'valid selector map'\n  });\n  ensureValueProvided(selectorKeys.length, {\n    prefix,\n    noun: 'non-empty selector map'\n  });\n  selectors.forEach((selector, index) => ensureValidSelector(selector, {\n    prefix,\n    noun: `selector for the '${selectorKeys[index]}' property`\n  }));\n}\n\nfunction createPickSelector(selector, keys) {\n  ensureValidSelector(selector, {\n    prefix: '[createPickSelector]'\n  });\n  const validKeys = keys.filter(Boolean);\n  const selectors = validKeys.map(key => createSelector([selector], s => s[key]));\n  return createSelector([...selectors], (...props) => {\n    return validKeys.reduce((acc, key, index) => {\n      acc[key] = props[index];\n      return acc;\n    }, {});\n  });\n}\n\nfunction createPropertySelectors(parentSelector) {\n  ensureValidSelector(parentSelector, {\n    prefix: '[createPropertySelectors]',\n    noun: 'parent selector'\n  });\n  const cache = {};\n  return new Proxy({}, {\n    get(_target, prop) {\n      const selector = cache[prop] || createSelector([parentSelector], s => s === null || s === void 0 ? void 0 : s[prop]);\n      cache[prop] = selector;\n      return selector;\n    }\n\n  });\n}\n/**\n * The public api for consumers of @ngxs/store\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Action, Actions, InitState, NGXS_PLUGINS, NgxsDevelopmentModule, NgxsModule, NgxsSimpleChange, NgxsUnhandledActionsLogger, NoopNgxsExecutionStrategy, Select, Selector, SelectorOptions, State, StateStream, StateToken, Store, UpdateState, actionMatcher, createModelSelector, createPickSelector, createPropertySelectors, createSelector, ensureSelectorMetadata, ensureStoreMetadata, getActionTypeFromInstance, getSelectorMetadata, getStoreMetadata, getValue, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, setValue, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule }; //# sourceMappingURL=ngxs-store.js.map",
  "map": null,
  "metadata": {},
  "sourceType": "module"
}
